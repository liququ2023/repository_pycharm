# 至少使用三种方法求解pi的值，并且比较它们的效率（精度保留到小数点后10位）

import random
import math

# 法一：公式法
print("法一：公式法(莱布尼茨级数)")
pi = 0
N = 1000
for n in range(int(N)):
    pi += 1/pow(16,n) * (4/(8*n+1) - 2/(8*n+4) - 1/(8*n+5) - 1/(8*n+6))
print('%.10f' % pi)

# 法二：蒙特卡罗法
# 我们用蒙特卡洛法来获得面积比Sy/Sz：让计算机产生很多的随机点(x,y)
# 其中x、y都是[0,1]之间的随机数，可以用判断(x*2 + y*2)是否小于1的方法来确定是否在圆内，则圆内的点数代表圆面积，总点数代表总面积，两者相除就是面积比Sy/Sz
print("法二：蒙特卡罗法")
s = 1e10
n = 0  # 点的个数
for i in range(int(s)):
    x = random.random()
    y = random.random()
    d = (x-0.5)**2+(y-0.5)**2
    if d <= 0.5**2:
        n += 1
    else:
        pass
pi = 4*n/s
print('%.10f' % pi)

# 法三：割园迭代法
# 设想一个圆，半径r=1，内接一个正n边形，边长为a，那么当这个多边形的边数n越大，它的周长就越接近圆的周长。所以我们就可以用多边形的周长代替圆的周长并应用圆的周长公式得到结论
print("法三：割园迭代法")
n = 6
a = 1
print("%-15s%-20s" % ("内接正n边形","π计算结果"))
# print("%-20d%-20.12f" % (n, n*a/2))
for i in range(14) :
  n = 2*n
  a = math.sqrt(2-2*math.sqrt(1-(a/2)**2))
print("%-20d%-20.10f" % (n, n*a/2))

# 法四：梅钦级数法
# 效率上的比较：蒙特卡洛法非常简单易懂，但是效率非常低，想要计算到十位有效数字速度很慢，要随机生成点在判断距离，而其他方法多是简单的循环迭代，效率高很多
